CREATE FUNCTION DateTimeTransform(sOriginalString CHAR) RETURNS CHAR
BEGIN
--The function removes the date from the input string.
--
--   Following are the cases that it will handle:
--   AD311130 -> AD1130
--   AD311130/311135 -> AD1130/1135
--   AD311130/311135 EA1140 -> AD1130/1135 EA1140


		--DECLARE sOriginalString CHAR;
		DECLARE sRestOfString CHAR;
		DECLARE sWorkingString CHAR;
		
		DECLARE iPositionOfSpace INT 0;
		DECLARE iPositionOfBackSlash INT 0;
		
		DECLARE iStartPosition INT 0;
		DECLARE iEndPosition INT 0;
		
		SET iPositionOfSpace = POSITION ( ' ' IN sOriginalString);

		IF ( iPositionOfSpace = 0 ) THEN
			SET sWorkingString = SUBSTRING(sOriginalString FROM 1 FOR LENGTH(sOriginalString) );
			SET sRestOfString = '';
		ELSE
			SET sWorkingString = SUBSTRING ( sOriginalString FROM 1 FOR iPositionOfSpace-1 );
			SET sRestOfString = SUBSTRING ( sOriginalString FROM iPositionOfSpace );
		END IF;
		
		SET iPositionOfBackSlash = POSITION ('/' IN sWorkingString);
		IF ( iPositionOfBackSlash = 0 ) THEN -- String does not contain '/'
			IF ( LENGTH( sWorkingString ) = 8 ) THEN---Ex AD204567 -> AD4567
				SET sWorkingString = SUBSTRING( sWorkingString FROM 1 FOR 2 ) || SUBSTRING(sWorkingString FROM 5 FOR 4);
			END IF;
		ELSE -- String contains '/'
			IF ( LENGTH( sWorkingString) = 15 ) THEN --- Ex AD204567/218901 -> AD4567/8901
				SET sWorkingString = SUBSTRING( sWorkingString FROM 1 FOR 2 ) || SUBSTRING(sWorkingString FROM 5 FOR 5) ||
										SUBSTRING( sWorkingString FROM 12 FOR 4 );
			END IF;
		END IF;
		
		SET sWorkingString = sWorkingString || sRestOfString ;
		RETURN sWorkingString;
END;


CREATE FUNCTION ifLegLineRemoveDate(sOriginalString CHAR) RETURNS CHAR
-- this function checks if the string is of the pattern "AER311245 KUL011160"
-- If yes then it converts the above string to "AER1245 KUL1160".  In other words, we are removing the date from the above string.
BEGIN
	DECLARE sWorkingString CHAR;
	
	SET sWorkingString = TRIM(sOriginalString);
	-- Check if the incoming string is of the pattern " 8characters followed by SPACE followed by 8 characters "
	IF sWorkingString LIKE '_________ _________' THEN
		--check if the 4th to 9th characters are numeric
		IF (SUBSTRING ( sWorkingString FROM 4 FOR 6 ) BETWEEN 000000 AND 999999) THEN 
			--remove the date: ex AER311245 KUL011160  -> AER1245 KUL1160
			SET sWorkingString = SUBSTRING ( sWorkingString FROM 1 FOR 3 ) ||
								 SUBSTRING ( sWorkingString FROM 6 FOR 5 ) ||
								 SUBSTRING ( sWorkingString FROM 11 FOR 3 ) ||
								 SUBSTRING ( sWorkingString FROM 16 );
			RETURN sWorkingString;
		ELSE
			-- send back the original string, we are not interested
			RETURN sOriginalString;
		END IF;
		RETURN sOriginalString;
	END IF;
	RETURN sOriginalString;
END;

CREATE FUNCTION getFMCSOutFilePath() RETURNS CHAR
BEGIN
	RETURN '/airops/data/IN';
END;

CREATE FUNCTION getMSSOutFilePath() RETURNS CHAR
BEGIN
	RETURN 'C:\Program Files\Omega Airline Software\AMES4\OPSBACK\';
END;

CREATE FUNCTION getMVSQueueManager() RETURNS CHAR
BEGIN
	RETURN 'QMP1';
END;

CREATE FUNCTION getExceptionNumber(IN InputExceptionList REFERENCE) RETURNS INTEGER
BEGIN
	
	DECLARE Error INTEGER;  /* Error number extracted from exception list */
	SET Error = 0;
	DECLARE Path CHARACTER;  /* Current path within the exception list */
	
	/* Start at first child of exception list */
	SET Path = 'InputExceptionList.*[1]';
	
	/* Loop until no more children */
	WHILE EVAL( 'FIELDNAME(' || Path || ') IS NOT NULL' ) DO
		/* Check if error number is available */
		IF EVAL( 'FIELDNAME(' || Path || '.Number) IS NOT NULL' ) THEN
			/* Remember only the deepest error number */
			SET Error = EVAL( Path || '.Number' );
		END IF;
	
		/* Step to last child of current element (usually a nested exception list */
		SET Path = Path || '.*[<]';
	END WHILE; /* End loop */
		
	RETURN Error;
END;


CREATE FUNCTION getParameter(IN cdata CHAR, IN param CHAR) RETURNS CHAR
BEGIN
	DECLARE iOpenTag INTEGER;
	DECLARE iCloseTag INTEGER;
	DECLARE iParam INTEGER;
	DECLARE value CHAR;
	
	DECLARE cOpenTag CHAR '<' || param || '>';
	DECLARE cCloseTag CHAR '</' || param || '>';
	
	DECLARE blnTagExist INTEGER;
	SET blnTagExist = POSITION(cOpenTag IN cdata);
	IF (blnTagExist = 0) THEN
		RETURN '';
	END IF;
	
	SET iOpenTag = POSITION(cOpenTag IN cdata) + LENGTH(cOpenTag);
	SET iCloseTag = POSITION(cCloseTag IN cdata);
	
	SET iParam = iCloseTag - iOpenTag;
	
	SET value = SUBSTRING(cdata FROM iOpenTag FOR iParam);
	RETURN value;
END;

CREATE FUNCTION removeElement(IN cdata CHAR, IN param CHAR) RETURNS CHAR
BEGIN
	DECLARE tagValue CHAR;
	DECLARE cOpenTag CHAR '<' || param || '>';
	DECLARE cCloseTag CHAR '</' || param || '>';
	
	SET tagValue = getParameter(cdata, param);
	SET cdata = REPLACE(cdata, cOpenTag || tagValue || cCloseTag, '');
	
	RETURN cdata;
END;

CREATE FUNCTION generateUniqueId(SoapReplyIdentifier BLOB) RETURNS CHAR
BEGIN
	
	DECLARE tmp CHAR;
	DECLARE currentDate CHAR(6);
	DECLARE currentTime CHAR(6);

	SET currentDate = CAST(EXTRACT(YEAR FROM CURRENT_DATE) AS CHAR FORMAT '00') ||
			CAST(EXTRACT(MONTH FROM CURRENT_DATE) AS CHAR FORMAT '00') ||
			CAST(EXTRACT(DAY FROM CURRENT_DATE) AS CHAR FORMAT '00');
	
	SET currentTime = CAST(EXTRACT(HOUR FROM CURRENT_TIME) AS CHAR FORMAT '00') ||
							CAST(EXTRACT(MINUTE FROM CURRENT_TIME) AS CHAR FORMAT '00') ||
							CAST(EXTRACT(SECOND FROM CURRENT_TIME) AS CHAR FORMAT '00');
	
	SET tmp = CAST(SoapReplyIdentifier AS CHARACTER);
	SET tmp = REPLACE(tmp, 'X''', '');
	SET tmp = REPLACE(tmp, '''', '');
	
	--RETURN currentDate || currentTime || '_' || tmp;
	RETURN getCurrentTimestamp() || '_' || tmp;
END;

CREATE FUNCTION getCurrentTimestamp() RETURNS CHAR
BEGIN	
	DECLARE ReceiveTime TIMESTAMP CURRENT_TIMESTAMP;
	DECLARE currentTimestamp CHAR;
		
	-- Modified the ReceiveTime to support sending Timestamp over XML format
	SET currentTimestamp = ReceiveTime;
	SET currentTimestamp = REPLACE(currentTimestamp, 'TIMESTAMP ', '');
	SET currentTimestamp = REPLACE(currentTimestamp, ' ', 'T');
	SET currentTimestamp = REPLACE(currentTimestamp, '''', '');
	
	RETURN currentTimestamp;
END;

CREATE FUNCTION getToken(IN data CHARACTER, IN del CHARACTER, IN no INTEGER, OUT value CHARACTER)
BEGIN
	DECLARE iStart INTEGER;
	DECLARE iEnd INTEGER;
	DECLARE iLength INTEGER;
	DECLARE iRepeat INTEGER;
	
	IF no > 1 THEN
		SET iRepeat = no - 1;
		SET iStart = POSITION(del IN data REPEAT iRepeat) + 1;
	ELSE
		SET iStart = 0;
	END IF;
	
	SET iRepeat = no;
	
	IF iRepeat > 1 THEN
		SET iEnd = POSITION(del IN data REPEAT iRepeat);
		IF iEnd = 0 THEN
			SET iEnd = LENGTH(data) + 1;
		END IF;
	ELSE
		SET iEnd = POSITION(del IN data);
	END IF;
	
	SET iLength = iEnd - iStart;
	
	SET value = SUBSTRING(data FROM iStart FOR iLength);
END;

CREATE FUNCTION getTransactionIdByArg(IN inTime TIMESTAMP, IN inPattern CHAR, IN inRandDigit INTEGER) RETURNS CHAR
BEGIN	
	DECLARE ReceiveTime TIMESTAMP CURRENT_TIMESTAMP;
	DECLARE currentTimestamp CHAR;
	DECLARE TransactionId CHAR;
	DECLARE fRandomNo FLOAT;
	DECLARE iRandomNo INTEGER;
	DECLARE cRandomNo CHAR '';
	DECLARE cPattern CHAR 'yyyyMMddHHmmssSSSSSS';
	DECLARE iRandDigit INTEGER 3;

	IF inTime IS NOT NULL THEN
		SET ReceiveTime = inTime;
	END IF;
	
	IF inPattern <> '' THEN
		SET cPattern = inPattern;
	END IF;
	
	IF inRandDigit > -1 THEN
		SET iRandDigit = inRandDigit;
	END IF;
	
	-- Only Generate Random Number when "iRandDigit" more than zero
	IF iRandDigit > 0 THEN
		-- Generate X Digit random number
		SET fRandomNo = RAND();
		SET iRandomNo = fRandomNo * POWER(10, iRandDigit);
		SET cRandomNo = iRandomNo;
	
		-- Double Check Random Digit Length (because when 0.04354646 * 100 only get 1 random digit that is '4')
		DECLARE I INTEGER LENGTH(cRandomNo);
	
		WHILE I < iRandDigit DO
			SET cRandomNo = '0' || cRandomNo;
			SET I = I + 1;
		END WHILE;
	END IF;
	
	SET TransactionId = CAST(ReceiveTime AS CHARACTER FORMAT cPattern);
	
	-- Append last X digit on random number
	RETURN TransactionId || cRandomNo;
END;

CREATE FUNCTION getTransactionIdByTime(IN inTimeStamp TIMESTAMP) RETURNS CHAR
BEGIN
	RETURN getTransactionIdByArg(inTimeStamp, '', -1);
END;

CREATE FUNCTION getTransactionId() RETURNS CHAR
BEGIN
	RETURN getTransactionIdByArg(NULL, '', -1);
END;

CREATE FUNCTION getUMBErrorMessage() RETURNS CHAR
BEGIN	
	DECLARE errDescEN CHAR 'Service is currently unavailable. Please try again later. ';
	DECLARE errDescMY CHAR 'Perkhidmatan tergendala sebentar. Sila cuba sebentar lagi.';
	
	RETURN errDescEN || errDescMY;
END;

CREATE FUNCTION getCurrentTimeInMilliseconds() RETURNS INTEGER
BEGIN	
		RETURN getCurrentTimeInMillisecondsArg(CURRENT_DATE);
END;

CREATE FUNCTION isNumeric(IN data CHAR) RETURNS BOOLEAN
BEGIN
	DECLARE I INT;
	DECLARE TMP_C CHAR;
	DECLARE TMP_C1 CHAR;
	DECLARE FLAG BOOLEAN;
	SET FLAG = TRUE;
	SET TMP_C = data;
	
	SET I = 1;
	myLoop : WHILE(I <= LENGTH(TMP_C)) DO
		SET TMP_C1 = SUBSTRING(TMP_C FROM I FOR 1);
		IF(TMP_C1 < '0' OR TMP_C1 > '9') THEN
			SET FLAG = FALSE;
			LEAVE myLoop;
		END IF;
		SET I = I +1;
	END WHILE myLoop;
	
	RETURN FLAG;
END;

CREATE FUNCTION getCurrentTimeInMillisecondsArg(In untilDate DATE) RETURNS INTEGER
BEGIN	
		DECLARE cSSSPattern CHARACTER 'SSS';
		
		DECLARE currentDays INTEGER;
		DECLARE since1970Days INTEGER;
		DECLARE epochDays INTEGER;
		
		DECLARE HoursToday INTEGER;
		DECLARE MinutesToday INTEGER;
		DECLARE secondsToday INTEGER;
		DECLARE totalSecondsToday INTEGER;
		DECLARE ctotalMilisecondsToday CHAR;
		DECLARE totalMilisecondsToday INTEGER;
		
		DECLARE currentTime TIME CURRENT_TIME;
		DECLARE currentTimeStamp TIME CURRENT_TIMESTAMP;
		
		DECLARE epochSecs INTEGER;
		DECLARE currentTimeInMiliseconds INTEGER;
		
		SET currentDays = EXTRACT(DAYS FROM untilDate);
		SET since1970Days = EXTRACT(DAYS FROM DATE '1970-01-01');
		SET epochDays = currentDays - since1970Days;
		
		SET HoursToday = EXTRACT(HOUR FROM currentTime);
		SET MinutesToday = EXTRACT(MINUTE FROM currentTime);
		SET secondsToday = EXTRACT(SECOND FROM currentTime);
		
		SET totalSecondsToday = (HoursToday * 3600) + (MinutesToday * 60) + secondsToday;
		
		SET epochSecs = (epochDays * 24 * 3600) + totalSecondsToday;
		
		SET ctotalMilisecondsToday = CAST(currentTimeStamp AS CHARACTER FORMAT cSSSPattern);
		SET totalMilisecondsToday = ctotalMilisecondsToday;
		
		SET currentTimeInMiliseconds = (epochSecs * 1000) + totalMilisecondsToday;
		
		RETURN currentTimeInMiliseconds;
END;

-- New Added
CREATE PROCEDURE getLastExceptionDetail(IN InputTree reference,OUT messageNumber integer,
	OUT messageText char)	
    /****************************************************************************
	 * A procedure that will get the details of the last exception from a message
	 * IN InputTree:  The incoming exception list
	 * IN messageNumber:  The last message numberr.
	 * IN messageText: The last message text.
	 *****************************************************************************/
   BEGIN
    -- Create a reference to the first child of the exception list
    declare ptrException reference to InputTree.*[1];
    -- keep looping while the moves to the child of exception list work 
	WHILE lastmove(ptrException) DO
		-- store the current values for the error number and text
		IF ptrException.Number is not null THEN
    		SET messageNumber = ptrException.Number;
    		SET messageText = ptrException.Text;
		END IF;
		-- now move to the last child which should be the next exceptionlist
		move ptrException lastchild;
	END WHILE; 
END;
