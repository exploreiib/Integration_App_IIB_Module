/*****************************************************************************************
Table -> EAI_ERRORLOG
 

Column                         Type      Type
name                           schema    name               Length   Scale Nulls

------------------------------ --------- ------------------ -------- ----- ------
COUNTER                        SYSIBM    CHARACTER                10     0 No

MSG_MQMD_MSGID                 SYSIBM    CHARACTER                48     0 No

MSG_IN_DATE                    SYSIBM    CHARACTER                10     0 Yes

MSG_IN_TIME                    SYSIBM    CHARACTER                 8     0 Yes

MSG_OUT_DATE                   SYSIBM    CHARACTER                10     0 Yes

MSG_OUT_TIME                   SYSIBM    CHARACTER                 8     0 Yes

ERROR_CODE                     SYSIBM    CHARACTER                10     0 Yes

ERROR_DESCRIPTION              SYSIBM    VARCHAR          		4000     0 Yes -- change according oracle needs (varchar2)

ERROR_EXCEPTIONLIST            SYSIBM    VARCHAR          		4000     0 Yes -- change according oracle needs (varchar2)

SRCE_QUEUE_NAME                SYSIBM    CHARACTER               200     0 Yes

SRCE_APP_NAME                  SYSIBM    CHARACTER               100     0 Yes

******************************************************************************************/

------------------------------------------------
-- DDL Statements for table "EAI_ERRORLOG"
------------------------------------------------
-- CREATE TABLE "EAI_ERRORLOG"  (
--		  "COUNTER" CHAR(10) NOT NULL , 
--		  "MSG_MQMD_MSGID" CHAR(48) NOT NULL , 
--		  "MSG_IN_DATE" CHAR(10), 
--		  "MSG_IN_TIME" CHAR(8), 
--		  "MSG_OUT_DATE" CHAR(10), 
--		  "MSG_OUT_TIME" CHAR(8), 
--		  "ERROR_CODE" CHAR(10) , 
--		  "ERROR_DESCRIPTION" LONG VARCHAR , 
--		  "ERROR_EXCEPTIONLIST" LONG VARCHAR , 
--		  "SRCE_QUEUE_NAME" CHAR(200) , 
--		  "SRCE_APP_NAME" CHAR(100) )   
--		 IN "USERSPACE1" ;   

CREATE COMPUTE MODULE MF_CMS_ERRORPROCESSING_Compute
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		
		CALL CopyMessageHeaders();
		
		DECLARE cSoapAuditId CHARACTER;
		
		SET cSoapAuditId = COALESCE(InputRoot.XMLNSC.ErrorMessage.SoapAuditId, '');
		SET Environment.ErrorMessage.ExceptionNumber = COALESCE(InputRoot.XMLNSC.ErrorMessage.ExceptionNumber, '');
		SET Environment.ErrorMessage.ExceptionText = COALESCE(InputRoot.XMLNSC.ErrorMessage.ExceptionText, '');
		SET Environment.ErrorMessage.SRCE_APP_NAME = COALESCE(InputRoot.XMLNSC.ErrorMessage.SRCE_APP_NAME, '');
		SET Environment.ErrorMessage.ERROR_FILTER = COALESCE(InputRoot.XMLNSC.ErrorMessage.ERROR_FILTER, '');
		SET Environment.ErrorMessage.SourceQueueName = COALESCE(InputRoot.XMLNSC.ErrorMessage.SourceQueueName, '');
		
		IF cSoapAuditId IS NULL OR cSoapAuditId = '' THEN
			SET Environment.ErrorMessage.MsgId = SUBSTRING ( CAST ( InputRoot.MQMD.MsgId AS CHARACTER ) FROM 3 FOR 48 );
		ELSE
			SET Environment.ErrorMessage.MsgId = cSoapAuditId;
		END IF;

		SET OutputRoot.XMLNSC.ExceptionList = InputRoot.XMLNSC.ErrorMessage.ExceptionList;
--		
----		CALL CopyMessageHeaders();
--		CALL CopyEntireMessage();
--		
----		DECLARE inputMsgRef REFERENCE TO InputRoot.XML.ErrorMessage ;
----		DECLARE envRef REFERENCE TO Environment ;
--		DECLARE msgInDate DATE;
--		DECLARE msgInTime TIME;
--		DECLARE cInTimestamp CHARACTER;
--		
--		-- Not null
--		SET Environment.Variable.COUNTER = 'DEFAULT';
--		-- Not null
--		SET Environment.Variable.MSG_MQMD_MSGID=SUBSTRING((CAST(InputRoot.MQMD.MsgId as char)) FROM 3 FOR 48);
--		
--		-- Add on the cater SOAP FLOW in WMBv6.1
--		IF(InputRoot.XML.ErrorMessage.SoapAuditId IS NOT NULL) THEN
--			SET Environment.Variable.MSG_MQMD_MSGID = InputRoot.XML.ErrorMessage.SoapAuditId; -- Overwrite the mqmq msg id to become SoapAuditId
--		END IF; 
--		
--		-- Not null
--		SET Environment.Variable.SRCE_QUEUE_NAME = InputRoot.XML.ErrorMessage.SourceQueueName;
--		SET Environment.Variable.SRCE_APP_NAME = InputRoot.XML.ErrorMessage.SRCE_APP_NAME;-- SUBSTRING ( InputRoot.XML.ErrorMessage.SourceQueueName FROM 4 FOR 4 );
--		SET Environment.Variable.ERROR_FILTER = InputRoot.XML.ErrorMessage.ERROR_FILTER;
--		
--		-- Added to support other than MQ INPUT Flow. Such as SOAP INPUT flow
--		IF (Environment.Variable.SRCE_QUEUE_NAME IS NULL) THEN
--			SET Environment.Variable.SRCE_QUEUE_NAME = '';--getNodeCauseError(InputRoot);
--			--SET Environment.Variable.SRCE_APP_NAME = getSoapMainFlow(InputRoot);
--		END IF;
--		
--		SET msgInDate = CAST (InputRoot.MQMD.PutDate AS DATE);
--		SET msgInTime = CAST (InputRoot.MQMD.PutTime AS TIME);
--		SET cInTimestamp = 'TO_TIMESTAMP(''' || SUBSTRING ( CAST ( msgInDate AS CHARACTER ) FROM 7 FOR 10 ) || 
--						' ' || SUBSTRING ( CAST ( msgInTime AS CHARACTER) FROM 7 FOR 12 ) || ''', ' ||
--						'''YYYY-MM-DD HH24:MI:SS.FF'')';
--		
--		
--		
--		SET Environment.Variable.sqlQuery='INSERT INTO WMBAUDIT.EAI_ERRORLOG (COUNTER, MSG_MQMD_MSGID, MSG_IN_DATE, MSG_OUT_DATE, ERROR_CODE, ERROR_DESCRIPTION, ERROR_EXCEPTIONLIST, SRCE_QUEUE_NAME, SRCE_APP_NAME, ERROR_FILTER) ';
--		SET Environment.Variable.sqlQuery=Environment.Variable.sqlQuery ||'VALUES ( ''' || Environment.Variable.COUNTER || ''', ''' || Environment.Variable.MSG_MQMD_MSGID || ''', ';
-- 
--				
--		SET Environment.Variable.sqlQuery = Environment.Variable.sqlQuery || cInTimestamp || ', ' ;
--		
--		SET Environment.Variable.sqlQuery = Environment.Variable.sqlQuery || 'SYSTIMESTAMP' || ', ' ;
--		
--		SET Environment.Variable.ERROR_CODE = InputRoot.XML.ErrorMessage.ExceptionNumber;
--		SET Environment.Variable.ERROR_DESCRIPTION = InputRoot.XML.ErrorMessage.ExceptionText;
--		
--		-- Create this condition checking to support the deployed flow but using existing common sub-flow
--		-- such as Active10, M+, Internation TopUp
--		IF Environment.Variable.ERROR_DESCRIPTION IS NULL THEN
--			DECLARE error_code INTEGER;
--			DECLARE error_desc CHARACTER;
--		
--			CALL getLastExceptionDetail(InputRoot.XML.ErrorMessage.ExceptionList, error_code, error_desc);
--			
--			SET Environment.Variable.ERROR_DESCRIPTION = error_desc;
--		END IF;
--		
--		-- SET Environment.Variable.ERROR_DESCRIPTION = InputRoot.XML.ErrorMessage.Text;
--		--SET Environment.Variable.ERROR_EXCEPTIONLIST = CAST ( CAST(InputRoot.XML.ExceptionList AS BLOB) AS CHAR CCSID InputRoot.MQMD.CodedCharSetId );
--            
	END;
	
	CREATE FUNCTION getSoapMainFlow (IN expList REFERENCE) RETURNS CHARACTER
	BEGIN
		DECLARE iHashPos INTEGER;
		DECLARE mainFlow CHARACTER;
		DECLARE data CHARACTER;
		
		-- SET mainFlow = expList.XML.ErrorMessage.ExceptionList.RecoverableException[>].Name[>];
		-- remark change hardcoded "RecoverableException" to "*" because to cater UserException as well
		SET mainFlow = expList.XML.ErrorMessage.ExceptionList.*[>].Name[>];
		
		SET iHashPos = POSITION('#' IN mainFlow);
		
		SET data = SUBSTRING ( mainFlow FROM 1 FOR (iHashPos - 1) );

		RETURN data;
	END;
	
	CREATE FUNCTION getNodeCauseError (IN expList REFERENCE) RETURNS CHARACTER
	BEGIN
		--RETURN expList.XML.ErrorMessage.ExceptionList.RecoverableException[>].Label[>];
		-- remark change hardcoded "RecoverableException" to "*" because to cater UserException as well
		RETURN expList.XML.ErrorMessage.ExceptionList.*[>].Label[>];
	END;
	
	-- New Added
	CREATE PROCEDURE getLastExceptionDetail(IN InputTree reference,OUT messageNumber integer,
		OUT messageText char)	
    /****************************************************************************
	 * A procedure that will get the details of the last exception from a message
	 * IN InputTree:  The incoming exception list
	 * IN messageNumber:  The last message numberr.
	 * IN messageText: The last message text.
	 *****************************************************************************/
   BEGIN
   	    -- Create a reference to the first child of the exception list
   	    declare ptrException reference to InputTree.*[1];
   	    -- keep looping while the moves to the child of exception list work 
		WHILE lastmove(ptrException) DO
			-- store the current values for the error number and text
			IF ptrException.Number is not null THEN
        		SET messageNumber = ptrException.Number;
        		SET messageText = ptrException.Text;
  			END IF;
  			-- now move to the last child which should be the next exceptionlist
			move ptrException lastchild;
		END WHILE; 
	END;
	
	CREATE PROCEDURE CopyMessageHeaders() BEGIN
		DECLARE I INTEGER 1;
		DECLARE J INTEGER CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			SET OutputRoot.*[I] = InputRoot.*[I];
			SET I = I + 1;
		END WHILE;
	END;

	CREATE PROCEDURE CopyEntireMessage() BEGIN
		SET OutputRoot = InputRoot;
	END;
	
END MODULE;


CREATE COMPUTE MODULE MF_CMS_ERRORPROCESSING_Compute1
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		
		DECLARE sSQLErrorMsg CHARACTER;
		DECLARE cCounter CHARACTER 'DEFAULT';
		DECLARE iExceptionListLength INTEGER;
		DECLARE bExceptionList BLOB;
		DECLARE cExceptionList CHARACTER;
		DECLARE cInTimestamp CHARACTER;
		DECLARE msgInDate DATE;
		DECLARE msgInTime TIME;
		
		SET msgInDate = CAST (InputRoot.MQMD.PutDate AS DATE);
		SET msgInTime = CAST (InputRoot.MQMD.PutTime AS TIME);
		SET cInTimestamp = 'TO_TIMESTAMP(''' || SUBSTRING ( CAST ( msgInDate AS CHARACTER ) FROM 7 FOR 10 ) || 
							' ' || SUBSTRING ( CAST ( msgInTime AS CHARACTER) FROM 7 FOR 12 ) || ''', ' ||
							'''YYYY-MM-DD HH24:MI:SS.FF'')';
		
		SET bExceptionList = BITSTREAM (InputBody);
		SET iExceptionListLength = LENGTH(bExceptionList);
		
		IF ( iExceptionListLength > 4000 ) THEN
			SET bExceptionList = SUBSTRING ( bExceptionList FROM 1 FOR 4000 );
		END IF;
		
		SET cExceptionList = CAST(bExceptionList AS CHAR CCSID InputRoot.Properties.CodedCharSetId);
		
		SET sSQLErrorMsg ='INSERT INTO WMBAUDIT.EAI_ERRORLOG (COUNTER, MSG_MQMD_MSGID, MSG_IN_DATE, MSG_OUT_DATE, ERROR_CODE, ERROR_DESCRIPTION, ERROR_EXCEPTIONLIST, SRCE_QUEUE_NAME, SRCE_APP_NAME, ERROR_FILTER) ';
		SET sSQLErrorMsg=sSQLErrorMsg ||'VALUES ( ''' || cCounter || ''', ''' || Environment.ErrorMessage.MsgId || ''', ';		
		SET sSQLErrorMsg = sSQLErrorMsg || cInTimestamp || ', ' ;
		SET sSQLErrorMsg = sSQLErrorMsg || 'SYSTIMESTAMP' || ', ' ;
		SET sSQLErrorMsg = sSQLErrorMsg || '''' || Environment.ErrorMessage.ExceptionNumber|| ''', ' ;
		SET sSQLErrorMsg = sSQLErrorMsg || '''' || Environment.ErrorMessage.ExceptionText || ''', ' ;
		SET sSQLErrorMsg = sSQLErrorMsg || '''' || cExceptionList || ''', ' ;		
		SET sSQLErrorMsg = sSQLErrorMsg || '''' || Environment.ErrorMessage.SourceQueueName || ''', ' ;
		SET sSQLErrorMsg = sSQLErrorMsg || '''' || Environment.ErrorMessage.SRCE_APP_NAME || ''', ' ;
		SET sSQLErrorMsg = sSQLErrorMsg || '''' || Environment.ErrorMessage.ERROR_FILTER || ''')' ;

		PASSTHRU(sSQLErrorMsg) ;

		SET Environment.ErrorMessage = NULL ;

		RETURN TRUE;
	END;
	
	CREATE PROCEDURE CopyMessageHeaders() BEGIN
		DECLARE I INTEGER 1;
		DECLARE J INTEGER CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			SET OutputRoot.*[I] = InputRoot.*[I];
			SET I = I + 1;
		END WHILE;
	END;

	CREATE PROCEDURE CopyEntireMessage() BEGIN
		SET OutputRoot = InputRoot;
	END;
END MODULE;


CREATE COMPUTE MODULE MF_CMS_BRK_ErrorProcessing_AuditErrorMsg
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN

		DECLARE iMsgBodyLength INT;

		DECLARE msgMqmdMsgid CHARACTER;
		DECLARE msgInDate DATE;
		DECLARE msgInTime TIME;
		DECLARE cCounter CHARACTER 'DEFAULT';
		DECLARE cSourceApp CHARACTER;
		DECLARE cAuditType CHARACTER;
		DECLARE cAuditFilter CHARACTER;
		DECLARE cSoapAuditId CHARACTER;
		DECLARE cWMBAuditBody CHARACTER;
		DECLARE cInTimestamp CHARACTER;
		DECLARE sSQLInsert CHARACTER;

		SET cSourceApp = InputRoot.XMLNSC.Audit.SRCE_APPL;
		SET cAuditType = InputRoot.XMLNSC.Audit.AUDIT_TYPE;
		SET cAuditFilter = InputRoot.XMLNSC.Audit.AUDIT_FILTER;
		SET cSoapAuditId = InputRoot.XMLNSC.Audit.SoapAuditId;
		SET cWMBAuditBody = InputRoot.XMLNSC.Audit.WMBAuditBody;
		
		SET iMsgBodyLength = LENGTH(cWMBAuditBody);
		
		IF cSoapAuditId IS NULL OR cSoapAuditId = '' THEN
			SET msgMqmdMsgid = cSoapAuditId;
		ELSE
			SET msgMqmdMsgid = SUBSTRING ( CAST ( InputRoot.MQMD.MsgId AS CHARACTER ) FROM 3 FOR 48 );
		END IF;
		
		IF iMsgBodyLength > 4000 THEN
			SET cWMBAuditBody = SUBSTRING(cWMBAuditBody FROM 1 FOR 4000);
		END IF;
		
		SET msgInDate = CAST (InputRoot.MQMD.PutDate AS DATE);
		SET msgInTime = CAST (InputRoot.MQMD.PutTime AS TIME);
		SET cInTimestamp = 'TO_TIMESTAMP(''' || SUBSTRING ( CAST ( msgInDate AS CHARACTER ) FROM 7 FOR 10 ) || 
						' ' || SUBSTRING ( CAST ( msgInTime AS CHARACTER) FROM 7 FOR 12 ) || ''', ' ||
						'''YYYY-MM-DD HH24:MI:SS.FF'')';
		
		-- COUNTER, MSG_MQMD_MSGID, MSG_IN_DATE, MSG_IN_TIME, MSG_OUT_DATE, MSG_OUT_TIME, SRCE_APPL, MSG_DATA
		
 		--SET envRef.Variable.sqlQuery = 'INSERT INTO WMBAUDIT.EAI_AUDIT_TRAIL ( COUNTER, MSG_MQMD_MSGID, MSG_IN_DATE, MSG_IN_TIME, MSG_OUT_DATE, MSG_OUT_TIME, SRCE_APPL, MSG_DATA ) VALUES ( ''' || envRef.Variable.COUNTER || ''' , ''' || envRef.Variable.MSG_MQMD_MSGID || ''', ';
 		SET sSQLInsert = 'INSERT INTO WMBAUDIT.EAI_AUDIT_TRAIL ( COUNTER, MSG_MQMD_MSGID, MSG_IN_DATE, MSG_OUT_DATE, SRCE_APP_NAME, AUDIT_TYPE, AUDIT_FILTER, MSG_DATA ) VALUES ( ''' || cCounter || ''' , ''' || msgMqmdMsgid || ''', ';
		
		SET sSQLInsert = sSQLInsert || cInTimestamp || ', ' ;
		--SET envRef.Variable.sqlQuery = envRef.Variable.sqlQuery || '''' || SUBSTRING ( CAST ( InputRoot.MQMD.PutDate AS CHARACTER ) FROM 7 FOR 10 ) || ''', ' ;
		--SET envRef.Variable.sqlQuery = envRef.Variable.sqlQuery || '''' || SUBSTRING ( CAST ( msgInTime AS CHARACTER) FROM 7 FOR 12 ) || ''', ' ;	

		SET sSQLInsert = sSQLInsert || 'SYSTIMESTAMP' || ', ' ;
		--SET sSQLInsert = envRef.Variable.sqlQuery || '''' || SUBSTRING ( CAST ( CURRENT_DATE AS CHARACTER ) FROM 7 FOR 10 ) || ''', ' ;
		--SET envRef.Variable.sqlQuery = envRef.Variable.sqlQuery || '''' || SUBSTRING ( CAST ( CURRENT_TIME AS CHARACTER ) FROM 7 FOR 12 ) || ''', ' ;	

		SET	sSQLInsert = sSQLInsert || '''' || cSourceApp || ''', ';
		
		SET	sSQLInsert = sSQLInsert || '''' || cAuditType || ''', ';
		
		SET	sSQLInsert = sSQLInsert || '''' || cAuditFilter || ''', ';
		
		SET sSQLInsert = sSQLInsert || '''' || cWMBAuditBody || ''')';
	
		PASSTHRU(sSQLInsert);

		-- Make sure to delete all the child below envRef.Variable.Variable - to avoid memory fragmentation
--		SET envRef.Variable.ORIGINAL_DATA = NULL ;
--		SET envRef.Variable = NULL ; 

		RETURN TRUE;
	END;

	CREATE PROCEDURE CopyMessageHeaders() BEGIN
		DECLARE I INTEGER 1;
		DECLARE J INTEGER;
		SET J = CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			SET OutputRoot.*[I] = InputRoot.*[I];
			SET I = I + 1;
		END WHILE;
	END;

	CREATE PROCEDURE CopyEntireMessage() BEGIN
		SET OutputRoot = InputRoot;
	END;
END MODULE;
